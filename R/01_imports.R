#' @title Import clustering results generated by other algorithms
#'
#' @description
#' The 'importResult()' function imports cell clustering results from two dataframes ('cells.count' and 'marker.expressions').
#' This function returns a 'Result' object.
#' 
#' @details
#' The 'cluster.abundances' dataframe must be formated with the cluster names in rownames as following:
#' 
#' \tabular{ccc}{
#'    X \tab sample1 \tab sample1\cr
#'    cluster1 \tab 749 \tab 5421\cr
#'    cluster2 \tab 450 \tab 412\cr
#' }
#' 
#' The 'cluster.phenotypes' dataframe must be formated as following:
#' 
#' \tabular{cccc}{
#'    sample \tab cluster \tab marker1 \tab marker2\cr
#'    sample1 \tab cluster1 \tab 0.2 \tab 0.3\cr
#'    sample1 \tab cluster2 \tab 0.1 \tab 0.3\cr
#'    sample2 \tab cluster1 \tab 0.5 \tab 2.3\cr
#'    sample2 \tab cluster2 \tab 1   \tab 1.3\cr
#' }
#' 
#' @param cluster.abundances a dataframe of cells abundances with clusters in row and samples in column 
#' @param cluster.phenotypes a dataframe containing median marker expression values for each cluster of each sample. In additions of markers, the 2 two first columns are are dedicated to "cluster" and "sample" 
#' @param th.min_cells a numeric specifying the minimun number of cell in a cluster of a sample to take in account its phenotype
#'
#' @return a S4 object of class 'Results'
#' 
#' @export 
importResults <- function(cluster.abundances,
                          cluster.phenotypes,
                          th.min_cells = 50) {

    colnames(cluster.phenotypes)[1] <- "sample"
    colnames(cluster.phenotypes)[2] <- "cluster"

    cluster.abundances[cluster.abundances < th.min_cells] <- 0

    min.bounds <- apply(cluster.phenotypes[, - c(1, 2)], 2, min, na.rm = TRUE)
    max.bounds <- apply(cluster.phenotypes[, - c(1, 2)], 2, max, na.rm = TRUE)
    bounds     <- as.data.frame(rbind(min = min.bounds, max = max.bounds))

    res <- methods::new("Results",
                        marker.expressions = cluster.phenotypes,
                        cells.count        = cluster.abundances,
                        sample.names       = colnames(cluster.abundances),
                        marker.names       = colnames(cluster.phenotypes)[3:length(cluster.phenotypes)],
                        cluster.number     = nrow(cluster.abundances),
                        bounds             = bounds)

    return(res)

}

#' @title Import clustering results generated by SPADE
#'
#' @description 
#' The 'importSPADEResults()' function imports SPADE cell clustering results from a specified path.
#' This function returns a 'SPADEResult' object.
#' 
#' This function import the expression matrix and count matrix as well as the SPADE tree.
#' This function apply an hyperbolic sine transformation to imported FCS data and compute the maker range quantiles.
#' 
#' @details
#' The computation of maker range quantiles can be approximated using 'quantile.approximation' parameter which is more efficient in term of loading time and memory usage.
#'  
#' @param path a character specify the path of SPADE results folder
#' @param dictionary a two column dataframe providing the correspondence between the original marker names (first column) and the real marker names (second column)
#' @param exclude.markers a character vector of markers to exclude (case insensitive)
#' @param probs a vector of probabilities with 2 values in [0,1] to compute maker range quantiles. First is the lower bound and second is the upper bound.
#' @param use.raw.medians a logical specifying if arcsinh transformed or raw medians will be used in the cluster expression matrix (FALSE by default)
#' @param quantile.approximation a logical specifying if maker range quantiles are computed using all cells (FALSE), or is the means of the quantile of each samples (TRUE)
#' @param th.min_cells a numeric specifying the minimun number of cell in a cluster of a sample to take in account its phenotype
#'
#' @return a S4 object of class 'SPADEResults'
#' 
#' @import flowCore 
#'
#' @export 
importSPADEResults <- function(path,
                               dictionary             = data.frame(),
                               exclude.markers        = c("cell_length", "FileNum", "density", "time"),
                               probs                  = c(0.05,0.95),
                               use.raw.medians        = FALSE,
                               quantile.approximation = FALSE,
                               th.min_cells           = 0) {
    
    message("[START] - extracting SPADE results")
    message(paste0(basename(path), "\n"))
    path <- normalizePath(path, "/")
    
    fcs.files <- dir(path, full.names = TRUE, pattern = ".fcs.density.fcs.cluster.fcs$")
    flowset <- load.flowSet(fcs.files = fcs.files, dictionary = dictionary, exclude.markers = exclude.markers, use.raw.medians = use.raw.medians)
    
    message("\tcompute quantiles...")
    
    if(quantile.approximation){
        quantiles <- computeQuantile.approximation(flowset,probs)
    }
    else{
        quantiles <- computeQuantile(flowset, probs)
    }
    gc()    
    message("\treading SPADE results...")
    
    files <- dir(paste(path, "/tables/bySample/", sep=""), full.names = TRUE)
    
    marker.expressions <- data.frame(stringsAsFactors = FALSE)
    cells.count        <- data.frame()
    cells.percent      <- data.frame()

    for(file in files){

        name <- gsub('.fcs.density.fcs.cluster.fcs.anno.Rsave_table.csv$', '', basename(file))
        SPADE.matrix       <- read.table(file, sep = ",", header = TRUE, stringsAsFactors = FALSE, check.names = FALSE)
        cells.count.sample <- SPADE.matrix [,"count"]

        cells.count.sample[cells.count.sample < th.min_cells] <- 0

        if(nrow(cells.count)){
            cells.count     <- cbind(cells.count, cells.count.sample)
            samples.headers <- append(samples.headers, name)
        }else{
            cells.count     <- data.frame(row.names = SPADE.matrix [, "ID"], cells.count.sample)
            samples.headers <- name
        }
        
        marker.expressions.sample <- SPADE.matrix[, grep("count|percenttotal", colnames(SPADE.matrix), invert = TRUE)]

        marker.expressions.sample[cells.count.sample == 0, 2:ncol(marker.expressions.sample)] <- rep(NA, ncol(marker.expressions.sample) - 1 )

        marker.expressions.sample <- cbind(name = rep(name, nrow(marker.expressions.sample)), marker.expressions.sample)
        marker.expressions        <- rbind(marker.expressions, marker.expressions.sample)
        
    }

    nb.cluster            <- nrow(cells.count)
    colnames(cells.count) <- samples.headers

    marker.expressions.header    <- colnames(marker.expressions)
    marker.expressions.header    <- gsub("X.", "(", marker.expressions.header, fixed = TRUE)
    marker.expressions.header    <- gsub(".", ")", marker.expressions.header, fixed = TRUE)
    marker.expressions.header[1] <- "sample"
    marker.expressions.header[2] <- "cluster"
    colnames(marker.expressions) <- marker.expressions.header
    
    marker.expressions <- filter.medians(marker.expressions,use.raw.medians)
    
    marker.expressions.header  <- colnames(marker.expressions)
    clustering.markers.index   <- grep("_clust",marker.expressions.header)
    marker.expressions.header  <- gsub("_clust","",marker.expressions.header)

    if(nrow(dictionary)>0){           
        colnames(marker.expressions)  <- rename.markers(marker.expressions.header, dictionary)    
    }else{
        colnames(marker.expressions)  <- marker.expressions.header
    }
    
    clustering.markers <- colnames(marker.expressions)[clustering.markers.index]

    if(!is.null(exclude.markers)){
        marker.expressions <- exclude.markers(marker.expressions, exclude.markers)
        clustering.markers <- setdiff(clustering.markers, exclude.markers)
    }

    graph        <- igraph::read.graph(paste(path, "./mst.gml", sep = ""), format = "gml")
    graph.layout <- as.matrix(read.table(paste0(path, "/layout.table"), sep = " ", quote = "", stringsAsFactors = FALSE))

    markers.names <- colnames(marker.expressions[, -c(1, 2)])

    res <- methods::new("SPADEResults",
                        marker.expressions  = marker.expressions,
                        use.raw.medians     = use.raw.medians,
                        dictionary          = dictionary,
                        cells.count         = cells.count,
                        sample.names        = flowCore::sampleNames(flowset),
                        marker.names        = markers.names,
                        marker.clustering   = markers.names %in% clustering.markers,
                        cluster.number      = nrow(cells.count),
                        flowset             = flowset,
                        fcs.files           = fcs.files,
                        bounds              = quantiles,
                        graph.layout        = graph.layout,
                        graph               = graph)
    
    message("[END] - extracting SPADE results")
    
    return(res)
    
}

#' @title Internal - Renaming cell markers
#' 
#' @description 
#' This function is used internally to rename the cell markers based on a dictionary.
#'
#' @details 
#' Dictionary is a data.frame used to rename the marker names. The first column must correspond to the original marker names, the second column must correspond to the new marker names. 
#'
#' @param header a character vector containing the original maker names
#' @param dictionary a character vector containing a correspondence between the original and the new marker names
#'
#' @return a character vector containing the renamed marker names
rename.markers <- function(header, dictionary) {
      
    dictionary[,1] <- as.vector(dictionary[,1])
    dictionary[,2] <- as.vector(dictionary[,2])
    
    if(length(unique(dictionary[,1])) != length(dictionary[,1])){
        stop(paste0("Duplicate in dictionary 'original marker names': ", setdiff(dictionary[,1], unique(dictionary[,1]))))
    }
    if(length(unique(dictionary[,2])) != length(dictionary[,2])){
        stop(paste0("Duplicate in dictionary 'new marker names': ", setdiff(dictionary[,2], unique(dictionary[,2]))))
    }
    header.old <- header
    for(i in 1:nrow(dictionary)){
        header[which(header == dictionary[i, 1])[1]] <- dictionary[i, 2]
    }

    return(header)
}

#' @title Internal - Removing of cell markers to exclude from a matrix
#'
#' @description 
#' This function is used internally to remove one or several cell markers.
#' 
#' @details 
#' If the data parameter is a dataframe the colnames.FCS parameter is ignored but if the data parameter is a flowset, the colnames.FCS parameter is required.
#' 
#' @param data a numeric matrix or flowset
#' @param exclude a character vector containing the cell markers to be excluded (case intensive)
#' @param colnames.FCS a character vector containing column names if data is a FCS flowset
#' 
#' @return a numeric matrix without the cell markers to exclude
exclude.markers <- function(data,exclude, colnames.FCS = NULL){
    
    if(!is.null(colnames.FCS)){
        column <- colnames.FCS
    }else{
        column <- colnames(data) 
    }

    exclude.flags <- toupper(exclude) %in% toupper(column)
    
    if(any(!(exclude.flags))){
       warning(paste0("Unknown marker to exclude: ", paste(exclude[!exclude.flags], collapse=", ")))
    }

    data    <- data[ , -which(toupper(column) %in% toupper(exclude))]

	return(data)
}

#' @title Internal - filter medians to exclude from a matrix
#'
#' @description 
#' This function is used internally to remove raw or transform medians from SPADE matrix. CVS medians are always removed.
#' 
#' @param data a SPADE matrix
#' @param use.raw.medians a logical specifying if "transformed" or "raw" medians will be use (FALSE by default)
#' 
#' @return a numeric matrix without the cell markers to exclude
filter.medians <- function(data,use.raw.medians = FALSE){

    if(use.raw.medians){
        exclude <- "^medians|^cvs"
    }else{
        exclude <- "^raw_medians|^cvs"
    }
    
    data           <- data[,grep(exclude, colnames(data), invert = TRUE, ignore.case = TRUE)]
    colnames(data) <- gsub("^medians|^cvs|^raw_medians", "", colnames(data))
    
    return(data)
    
}

#' @title Internal - Compute quantile with FCS flowset marker by marker 
#'
#' @description 
#' This function is used internally to compute the maker range quantiles.
#' 
#' @details 
#' This function performs the exact calculation of quantiles with all cells but needs more ressources (time and memory usage) than 'computeQuantile.approximation'.
#' 
#' @param flowset a flowCore flowset
#' @param probs a numeric vector of 2 values specifying the quantiles to compute
#' 
#' @return a numeric matrix containing the quantiles of each marker
#' 
#' @import flowCore
computeQuantile <- function(flowset,probs = c(0.05,0.95)){

    bounds  <- data.frame ()
    markers <- flowset@colnames
    markers <- setdiff(markers,"cluster")
    
    for(marker in markers){
        temp <- c()
        for (sample in 1:length(flowset)){    
            frame <- flowset[[sample]]@exprs
            temp  <- c(temp, frame[,marker])
        }
        if(nrow(bounds) > 0){
            bounds <- cbind(bounds, quantile(temp, probs = probs))
        }else{
            bounds <- as.data.frame(quantile(temp, probs = probs))
        }
    }

    colnames(bounds) <- markers
    rownames(bounds) <- probs
    
    return(bounds)
}

#' @title Internal - Compute quantile with FCS flowset sample by sample
#'
#' @description 
#' This function is used internally to provide the mean of quantiles from each sample to seed up computation.
#' 
#' @details 
#' This function performs an approximate calculation of quantiles using less memory than computeQuantile.
#' 
#' @param flowset a flowCore flowset 
#' @param probs a numeric vector of 2 values specifying the quantiles to compute
#' 
#' @import flowCore
#' 
#' @return a numeric matrix containing the quantiles of each marker
computeQuantile.approximation <- function(flowset,probs = c(0.05,0.95)){
    
    bounds.by.sample <- flowCore::fsApply(flowset[,flowset@colnames != "cluster"], flowCore::each_col, stats::quantile, probs = probs)

    lower.bounds <- bounds.by.sample[seq(from = 1,to = nrow(bounds.by.sample), by = 2),]
    upper.bounds <- bounds.by.sample[seq(from = 2,to = nrow(bounds.by.sample), by = 2),]
    
    lower.bounds <- apply(lower.bounds,2,mean)
    upper.bounds <- apply(upper.bounds,2,mean)
    
    bounds <- data.frame(row.names = probs, rbind(lower.bounds, upper.bounds))
    
    return (bounds)
    
}

#' @title Load FCS files object into a 'SPADEResult' object
#'
#' @description 
#' This function loads the FCS files to the 'flowset' slot of the 'SPADEResult' object.
#' @details
#' If a 'SPADEResult' object is provided, others parameters ('fcs.files', 'dictionary', 'exclude.markers', 'use.raw.medians') will be ignored.
#' @param SPADEResult a SPADEResult object (optional)
#' @param fcs.files a character vector containing the absolute path of the original FCS files
#' @param dictionary a two column data.frame providing the correspondence between the original marker names (first column) and the real marker names (second column)
#' @param exclude.markers a character vector of markers to exclude (case insensitive)
#' @param use.raw.medians a logical specifying if the arcsinh transformation must be performed or not
#' 
#' @return a S4 'flowSet' object
#' 
#' @import flowCore 
#'
#' @export 
load.flowSet <- function(SPADEResult = NULL, fcs.files, dictionary, exclude.markers, use.raw.medians) {
    
    message("FCS files loading:")
    
    if (!is.null(SPADEResult)){
        dictionary <- SPADEResult@dictionary
        fcs.files  <- SPADEResult@fcs.files
    }
    print(fcs.files)
    flowset                        <- flowCore::read.flowSet(fcs.files, emptyValue = TRUE)
    samples.names                  <- gsub(".fcs.density.fcs.cluster.fcs", "", basename(fcs.files))
    flowCore::sampleNames(flowset) <- samples.names
      
    if(nrow(dictionary)>0){
        flowset@colnames <- rename.markers(flowset@colnames, dictionary)
    }
    
    if (!is.null(SPADEResult)){
        exclude.markers  <- setdiff(flowset@colnames, c(SPADEResult@marker.names, "cluster"))
    }
    
    if (!is.null(exclude.markers)){
        flowset <- exclude.markers(flowset, exclude.markers, colnames.FCS = flowset@colnames)
    }

    if ((is.null(SPADEResult) && !use.raw.medians) || !SPADEResult@use.raw.medians) {
        message("\tarchsin transform...")

        transform.arcsinh  <- flowCore::arcsinhTransform(a = 0, b = 0.2) #a and b match SPADE a and b
        marker.toTransform <- setdiff(flowset@colnames, c("cluster"))
        transformations    <- flowCore::transformList(marker.toTransform, transform.arcsinh)
        flowset <- flowCore::transform(flowset, transformations)
    }

    return(flowset)

}

#' @title Unload 'flowSet' object from a 'SPADEResult' object
#'
#' @description 
#' This function unloads the 'flowSet' object in a 'SPADEResult' object.
#' @param SPADEResult a SPADEResult object (optional)
#' @return The new 'SPADEResult' object
#' @export 
unload.flowSet <- function(SPADEResult) {

    SPADEResult@flowset <- NULL
    gc()

    return(SPADEResult)

}